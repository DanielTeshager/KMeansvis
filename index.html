<!DOCTYPE html>
<html>
	<head>
		<title>K-means Clustering Visualization</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				background-color: #f5f5f5;
				margin: 0;
				padding: 20px;
			}
			h1 {
				text-align: center;
				color: #333;
			}
			.container {
				display: flex;
				flex-direction: column;
				align-items: center;
			}
			.input-group {
				margin-bottom: 10px;
			}
			.input-group label {
				margin-right: 10px;
			}
			.button {
				padding: 10px 20px;
				background-color: #4caf50;
				color: white;
				border: none;
				cursor: pointer;
				margin-bottom: 20px;
			}
			.iteration {
				text-align: center;
				margin-bottom: 10px;
				font-size: 18px;
				color: #333;
			}
			canvas {
				border: 1px solid #ccc;
				background-color: white;
			}
			.explanation {
				max-width: 800px;
				margin: 0 auto;
				margin-bottom: 20px;
				text-align: justify;
				line-height: 1.6;
				color: #333;
				display: none;
			}
			.legend {
				margin-bottom: 10px;
				color: #333;
			}
			.legend-item {
				display: flex;
				align-items: center;
				margin-bottom: 5px;
			}
			.legend-color {
				width: 20px;
				height: 20px;
				margin-right: 5px;
			}
			.algorithm-steps {
				margin-top: 20px;
				display: flex;
				flex-wrap: wrap;
				justify-content: space-between;
			}
			.step-container {
				width: 30%;
				margin-bottom: 20px;
				border: 1px solid #ccc;
				padding: 10px;
			}
			.step-container h3 {
				margin-top: 0;
			}
			.step-container table {
				width: 100%;
				border-collapse: collapse;
			}
			.step-container th,
			.step-container td {
				border: 1px solid #ccc;
				padding: 5px;
				text-align: center;
			}
			.visualization-container {
				display: flex;
			}
			.canvas-container {
				flex: 1;
				position: relative;
			}
			.table-container {
				flex: 1;
				margin-left: 20px;
				overflow: auto;
				max-height: 600px;
			}
			.table-container table {
				width: 100%;
				border-collapse: collapse;
			}
			.table-container th,
			.table-container td {
				border: 1px solid #ccc;
				padding: 5px;
				text-align: center;
			}
			.toggle-button {
				position: absolute;
				top: 10px;
				right: 10px;
				padding: 5px 10px;
				background-color: #4caf50;
				color: white;
				border: none;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<h1>K-means Clustering Visualization</h1>
		<div class="explanation">
			<p>
				K-means clustering is an unsupervised machine learning algorithm that
				partitions a dataset into K clusters. Each data point is assigned to the
				cluster with the nearest centroid (mean) based on its features. The
				algorithm iteratively updates the centroids and reassigns the data
				points until convergence.
			</p>
			<p>
				In this visualization, you can specify the number of data points and the
				desired number of clusters (centroids). The data points are randomly
				generated and displayed on a 2D canvas. The algorithm will iteratively
				assign each data point to the nearest centroid and update the centroid
				positions until the clusters stabilize.
			</p>
		</div>
		<div class="container">
			<div class="input-group">
				<label for="data-file">Upload Data File (CSV):</label>
				<input type="file" id="data-file" accept=".csv" />
			</div>
			<div class="input-group">
				<label for="generate-random">
					<input type="checkbox" id="generate-random" />
					Generate Random Data
				</label>
			</div>
			<div class="input-group">
				<label for="num-centroids">Number of Clusters (Centroids):</label>
				<input type="number" id="num-centroids" value="3" />
			</div>
			<button class="button" onclick="startVisualization()">
				Start Clustering
			</button>
			<div class="iteration"></div>
			<div class="visualization-container">
				<div class="canvas-container">
					<canvas id="canvas" width="800" height="600"></canvas>
					<button class="toggle-button" onclick="toggleTableVisibility()">
						Toggle Table
					</button>
				</div>
				<div class="table-container">
					<h3>New Centroids</h3>
					<table id="new-centroids-table">
						<thead>
							<tr>
								<th>Centroid</th>
								<th>X</th>
								<th>Y</th>
							</tr>
						</thead>
						<tbody></tbody>
					</table>
					<h2>Algorithm Steps</h2>
					<table id="step-table">
						<thead>
							<tr>
								<th>Point</th>
								<!-- Dynamically generate centroid distance columns -->
								<th>Assigned Centroid</th>
							</tr>
						</thead>
						<tbody></tbody>
					</table>
				</div>
			</div>
		</div>

		<script>
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const iterationElement = document.querySelector(".iteration");

			// Define colors for centroids
			const centroidColors = [
				"red",
				"green",
				"blue",
				"orange",
				"purple",
				"black",
				"violet",
				"indigo",
				"yellow",
			];

			function startVisualization() {
				const dataFile = document.getElementById("data-file").files[0];
				const generateRandom =
					document.getElementById("generate-random").checked;
				const numCentroids = parseInt(
					document.getElementById("num-centroids").value
				);

				if (!generateRandom && !dataFile) {
					alert("Please upload a data file or select 'Generate Random Data'.");
					return;
				}

				const formData = new FormData();
				if (generateRandom) {
					formData.append("generate_random", true);
				} else {
					formData.append("data_file", dataFile);
				}
				formData.append("num_centroids", numCentroids);

				fetch("http://127.0.0.1:5001/kmeans", {
					method: "POST",
					body: formData,
				})
					.then((response) => response.json())
					.then((iterations) => {
						// Clear the file input field
						document.getElementById("data-file").value = "";

						let currentIteration = 0;

						function drawIteration() {
							// Display algorithm steps
							const iteration = iterations[currentIteration];
							const stepTable = document.querySelector("#step-table");
							const stepTableHeader = stepTable.querySelector("thead tr");
							const stepTableBody = stepTable.querySelector("tbody");
							const newCentroidsTable = document.querySelector(
								"#new-centroids-table tbody"
							);

							// Clear previous data
							stepTableHeader.innerHTML = "<th>Point</th>";
							stepTableBody.innerHTML = "";
							newCentroidsTable.innerHTML = "";

							// Generate centroid distance columns dynamically
							for (let i = 0; i < numCentroids; i++) {
								stepTableHeader.innerHTML += `<th>Centroid ${
									i + 1
								} Distance</th>`;
							}
							stepTableHeader.innerHTML += "<th>Assigned Centroid</th>";

							// Distance Calculation and Assignment
							iteration.points.forEach((point, pointIndex) => {
								const row = document.createElement("tr");
								const pointColor =
									currentIteration === 0
										? "gray"
										: centroidColors[iteration.assignments[pointIndex]];
								row.innerHTML = `<td style="background-color: ${pointColor};">Point ${
									pointIndex + 1
								}</td>`;
								iteration.centroids.forEach((centroid) => {
									const distance = Math.sqrt(
										Math.pow(point[0] - centroid[0], 2) +
											Math.pow(point[1] - centroid[1], 2)
									);
									row.innerHTML += `<td>${distance.toFixed(2)}</td>`;
								});
								row.innerHTML += `<td>Centroid ${
									iteration.assignments[pointIndex] + 1
								}</td>`;
								stepTableBody.appendChild(row);
							});

							// New Centroids
							iteration.centroids.forEach((centroid, index) => {
								const row = document.createElement("tr");
								const centroidColor = centroidColors[index];
								row.innerHTML = `
                        <td style="background-color: ${centroidColor};">Centroid ${
									index + 1
								}</td>
                        <td>${centroid[0].toFixed(2)}</td>
                        <td>${centroid[1].toFixed(2)}</td>
                    `;
								newCentroidsTable.appendChild(row);
							});

							ctx.clearRect(0, 0, canvas.width, canvas.height);

							// Find the minimum and maximum values for scaling
							const xValues = iteration.points.map((point) => point[0]);
							const yValues = iteration.points.map((point) => point[1]);
							const minX = Math.min(...xValues);
							const maxX = Math.max(...xValues);
							const minY = Math.min(...yValues);
							const maxY = Math.max(...yValues);

							// Calculate the range of the data
							const rangeX = maxX - minX;
							const rangeY = maxY - minY;

							// Calculate the scaling factors to fit the data within 80% of the canvas
							const scaleX = (0.8 * canvas.width) / rangeX;
							const scaleY = (0.8 * canvas.height) / rangeY;

							// Calculate the offset to center the visualization
							const offsetX = (canvas.width - rangeX * scaleX) / 2;
							const offsetY = (canvas.height - rangeY * scaleY) / 2;

							// Draw Voronoi diagram lines
							if (currentIteration > 0) {
								ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
								ctx.beginPath();
								for (let i = 0; i < iteration.points.length; i++) {
									const [x, y] = iteration.points[i];
									const assignment = iteration.assignments[i];
									const [centroidX, centroidY] =
										iteration.centroids[assignment];

									ctx.moveTo(
										(x - minX) * scaleX + offsetX,
										(y - minY) * scaleY + offsetY
									);
									ctx.lineTo(
										(centroidX - minX) * scaleX + offsetX,
										(centroidY - minY) * scaleY + offsetY
									);
								}
								ctx.lineWidth = 1;
								ctx.stroke();
							}

							// Draw points with labels
							iteration.points.forEach((point, index) => {
								const [x, y] = point;
								const assignment = iteration.assignments[index];
								const label = iteration.labels[index];
								const pointColor =
									currentIteration === 0 ? "gray" : centroidColors[assignment];

								ctx.beginPath();
								ctx.arc(
									(x - minX) * scaleX + offsetX,
									(y - minY) * scaleY + offsetY,
									4,
									0,
									2 * Math.PI
								);
								ctx.fillStyle = pointColor;
								ctx.fill();

								ctx.fillStyle = "black";
								ctx.font = "12px Arial";
								ctx.fillText(
									label,
									(x - minX) * scaleX + offsetX + 8,
									(y - minY) * scaleY + offsetY
								);
							});

							// Draw centroids
							if (currentIteration > 0) {
								iteration.centroids.forEach((centroid, index) => {
									const [x, y] = centroid;
									ctx.beginPath();
									ctx.arc(
										(x - minX) * scaleX + offsetX,
										(y - minY) * scaleY + offsetY,
										16,
										0,
										2 * Math.PI
									);
									ctx.fillStyle = centroidColors[index];
									ctx.fill();
									ctx.lineWidth = 5;
									ctx.strokeStyle = "white";
									ctx.stroke();
								});
							}

							iterationElement.textContent = `Iteration: ${
								currentIteration + 1
							}`;

							currentIteration++;
							if (currentIteration < iterations.length) {
								setTimeout(drawIteration, 1000);
							}
						}

						drawIteration();
					});
			}

			function toggleTableVisibility() {
				const tableContainer = document.querySelector(".table-container");
				tableContainer.style.display =
					tableContainer.style.display === "none" ? "block" : "none";
			}
		</script>
	</body>
</html>
